<!DOCTYPE html>

<html class="writer-html5" lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="../../../img/favicon.ico" rel="shortcut icon"/>
<title>Equivalent Resistance Calculation Using Graph Theory - Physics and Mathematics</title>
<link href="../../../css/theme.css" rel="stylesheet"/>
<link href="../../../css/theme_extra.css" rel="stylesheet"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" rel="stylesheet"/>
<script>
        // Current page data
        var mkdocs_page_name = "Equivalent Resistance Calculation Using Graph Theory";
        var mkdocs_page_input_path = "1 Physics/5 Circuits/Problem_1.md";
        var mkdocs_page_url = null;
      </script>
<!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/yaml.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/rust.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/python.min.js"></script>
<script>hljs.highlightAll();</script>
</head>
<body class="wy-body-for-nav" role="document">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side stickynav" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search">
<a class="icon icon-home" href="../../.."> Physics and Mathematics
        </a><div role="search">
<form action="../../../search.html" class="wy-form" id="rtd-search-form" method="get">
<input aria-label="Search docs" name="q" placeholder="Search docs" title="Type search term here" type="text"/>
</form>
</div>
</div>
<div aria-label="Navigation menu" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../..">Introduction</a>
</li>
</ul>
<p class="caption"><span class="caption-text">1 Physics</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal">1 Mechanics</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../1%20Mechanics/Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../1%20Mechanics/Problem_2/">Problem 2</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">2 Gravity</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_2/">Problem 2</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_3/">Problem 3</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">3 Waves</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../3%20Waves/Problem_1/">Interference Patterns on a Water Surface</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">4 Electromagnetism</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../4%20Electromagnetism/Problem_1/">Lorentz Force Simulation</a>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal current">5 Circuits</a>
<ul class="current">
<li class="toctree-l2 current"><a class="reference internal current" href="#">Equivalent Resistance Calculation Using Graph Theory</a>
<ul class="current">
<li class="toctree-l3"><a class="reference internal" href="#1-introduction">1. Introduction</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#2-algorithm-description">2. Algorithm Description</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#21-basic-reduction-rules">2.1 Basic Reduction Rules</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#22-advanced-techniques">2.2 Advanced Techniques</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#1-y-wye-delta-transformation">1. Y-Δ (Wye-Delta) Transformation:</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#2-node-elimination-method">2. Node Elimination Method:</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#23-algorithm-flow">2.3 Algorithm Flow</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#3-implementation">3. Implementation</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#4-example-circuits-and-visual-representations">4. Example Circuits and Visual Representations</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#41-example-1-simple-series-parallel-circuit">4.1 Example 1: Simple Series-Parallel Circuit</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#42-example-2-wheatstone-bridge-circuit">4.2 Example 2: Wheatstone Bridge Circuit</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#43-example-3-complex-mesh-circuit">4.3 Example 3: Complex Mesh Circuit</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#5-algorithm-analysis">5. Algorithm Analysis</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#51-time-complexity">5.1 Time Complexity</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#52-space-complexity">5.2 Space Complexity</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#53-strengths">5.3 Strengths</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#54-potential-improvements">5.4 Potential Improvements</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#6-conclusion">6. Conclusion</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#7-example-python-usage">7. Example Python Usage</a>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">6 Statistics</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../6%20Statistics/Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../6%20Statistics/Problem_2/">Problem 2</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">7 Measurements</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../7%20Measurements/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">2 Mathematics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/1%20Linear_algebra/">Linear Algebra</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/2%20Analytic_geometry/">Analytic geometry</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/3%20Calculus/">Calculus</a>
</li>
</ul>
<p class="caption"><span class="caption-text">3 Discret Mathematics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal">1 Set Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/">Set Theory</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/">Relations</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/">Functions</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">2 Number Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/">Combinatorics</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/">Number Theory</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">3 Recurrence and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/">Sequences and Series</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/">Induction</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/">Recurrence</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">4 Graph Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/">Graph Theory</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">5 Logic</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/5%20Logic/_01%20Logic/">Logic</a>
</li>
</ul>
</li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">
<nav aria-label="Mobile navigation menu" class="wy-nav-top" role="navigation">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="../../..">Physics and Mathematics</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content"><div aria-label="breadcrumbs navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a aria-label="Docs" class="icon icon-home" href="../../.."></a></li>
<li class="breadcrumb-item">1 Physics</li>
<li class="breadcrumb-item">5 Circuits</li>
<li class="breadcrumb-item active">Equivalent Resistance Calculation Using Graph Theory</li>
<li class="wy-breadcrumbs-aside">
</li>
</ul>
<hr/>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div class="section" itemprop="articleBody">
<h1 id="equivalent-resistance-calculation-using-graph-theory">Equivalent Resistance Calculation Using Graph Theory</h1>
<h2 id="1-introduction">1. Introduction</h2>
<p>Calculating the equivalent resistance of electrical circuits is a fundamental problem in electrical engineering. Traditional methods involve iteratively applying series and parallel rules, which becomes increasingly complex for circuits with multiple cycles and complex topologies.</p>
<p>By representing circuits as graphs, we can leverage graph theory to systematically reduce and analyze any circuit configuration:
- <strong>Nodes</strong> represent junctions in the circuit
- <strong>Edges</strong> represent resistors with weights equal to resistance values
- <strong>Source and sink</strong> nodes represent the terminals across which we measure equivalent resistance</p>
<h2 id="2-algorithm-description">2. Algorithm Description</h2>
<p>Our algorithm combines multiple techniques to handle circuits of any complexity:</p>
<h3 id="21-basic-reduction-rules">2.1 Basic Reduction Rules</h3>
<ol>
<li><strong>Series Reduction</strong>:                  </li>
<li><strong>Condition</strong>: A node has exactly 2 connections and is neither source nor sink</li>
<li><strong>Action</strong>: Replace the node and its two adjacent resistors with a single resistor equal to their sum</li>
<li>
<p><strong>Formula</strong>: <span class="arithmatex">\(R_{eq} = R_1 + R_2\)</span></p>
</li>
<li>
<p><strong>Parallel Reduction</strong>:                        </p>
</li>
<li><strong>Condition</strong>: Multiple resistors directly connect the same pair of nodes</li>
<li><strong>Action</strong>: Replace them with a single equivalent resistor</li>
<li><strong>Formula</strong>: <span class="arithmatex">\(\frac{1}{R_{eq}} = \frac{1}{R_1} + \frac{1}{R_2} + ... + \frac{1}{R_n}\)</span></li>
</ol>
<h3 id="22-advanced-techniques">2.2 Advanced Techniques</h3>
<p>For circuits that cannot be fully reduced using only series and parallel reductions:</p>
<h3 id="1-y-wye-delta-transformation">1. <strong>Y-Δ (Wye-Delta) Transformation</strong>:</h3>
<ul>
<li>
<p>Transforms three resistors in Y configuration to three resistors in Δ configuration or vice versa.</p>
</li>
<li>
<p><strong>Y to Δ conversion</strong>:
  $$
  R_{AB} = \frac{R_A R_B + R_B R_C + R_C R_A}{R_C}
  $$
  $$
  R_{BC} = \frac{R_A R_B + R_B R_C + R_C R_A}{R_A}
  $$
  $$
  R_{CA} = \frac{R_A R_B + R_B R_C + R_C R_A}{R_B}
  $$</p>
</li>
<li>
<p><strong>Δ to Y conversion</strong>:
  $$
  R_A = \frac{R_{AB} R_{CA}}{R_{AB} + R_{BC} + R_{CA}}
  $$
  $$
  R_B = \frac{R_{AB} R_{BC}}{R_{AB} + R_{BC} + R_{CA}}
  $$
  $$
  R_C = \frac{R_{BC} R_{CA}}{R_{AB} + R_{BC} + R_{CA}}
  $$</p>
</li>
</ul>
<hr/>
<h3 id="2-node-elimination-method">2. <strong>Node Elimination Method</strong>:</h3>
<ul>
<li>Based on Kirchhoff’s laws and nodal analysis.</li>
<li>Uses matrix operations to systematically eliminate nodes.</li>
</ul>
<hr/>
<h3 id="23-algorithm-flow">2.3 Algorithm Flow</h3>
<pre><code>ALGORITHM CalculateEquivalentResistance(G, source, sink):
    Initialize graph G with resistors as weighted edges
    Store original graph for visualization

    WHILE circuit not fully reduced:
        Apply all possible parallel reductions
        Apply all possible series reductions

        IF no reductions possible:
            IF Y-Delta transformations applicable:
                Apply Y-Delta transformation
            ELSE:
                Use node elimination method
                BREAK

    RETURN resistance between source and sink
</code></pre>
<h2 id="3-implementation">3. Implementation</h2>
<p>Here's a complete Python implementation using NetworkX:</p>
<pre><code class="language-python">import networkx as nx
import numpy as np
import matplotlib.pyplot as plt
from typing import Tuple, Dict, Optional

class CircuitAnalyzer:
    def __init__(self, graph: nx.Graph, source: int, sink: int):
        """
        Initialize circuit analyzer with a graph representation of the circuit.

        Args:
            graph: NetworkX Graph where edges have 'weight' attribute representing resistance
            source: Source node (input terminal)
            sink: Sink node (output terminal)
        """
        self.original_graph = graph.copy()
        self.source = source
        self.sink = sink
        self.reduction_steps = []  # Store reduction steps for visualization

    def calculate_equivalent_resistance(self, debug: bool = False) -&gt; float:
        """Calculate the equivalent resistance between source and sink nodes."""
        # Start with a fresh copy of the original graph
        g = self.original_graph.copy()
        self.reduction_steps = [("Original Circuit", g.copy())]

        # Keep applying reductions until we can't reduce further
        while True:
            parallel_count = self._reduce_all_parallel(g, debug)
            series_count = self._reduce_all_series(g, debug)

            # If no reductions were made, we're done with basic methods
            if parallel_count == 0 and series_count == 0:
                break

        # Check if we have a direct connection between source and sink
        if g.number_of_edges() == 1 and g.has_edge(self.source, self.sink):
            r_eq = g[self.source][self.sink]['weight']
            self.reduction_steps.append(("Final Reduced Circuit", g.copy()))
            if debug:
                print(f"Circuit fully reduced to {r_eq} ohms")
            return r_eq

        # If basic reductions couldn't fully reduce the circuit, try Y-Delta transformations
        if debug:
            print("Basic reductions insufficient. Attempting Y-Delta transformations...")

        delta_reductions = self._apply_y_delta_transformations(g, debug)

        # After Y-Delta, try basic reductions again
        if delta_reductions &gt; 0:
            while True:
                parallel_count = self._reduce_all_parallel(g, debug)
                series_count = self._reduce_all_series(g, debug)
                if parallel_count == 0 and series_count == 0:
                    break

        # Check if we now have a direct connection
        if g.number_of_edges() == 1 and g.has_edge(self.source, self.sink):
            r_eq = g[self.source][self.sink]['weight']
            self.reduction_steps.append(("Final Reduced Circuit", g.copy()))
            return r_eq

        # If still not reduced, use the node elimination method
        if debug:
            print("Using node elimination method...")

        r_eq = self._node_elimination_method(g, debug)
        self.reduction_steps.append(("Final Result (Node Elimination)", 
                                   nx.Graph([(self.source, self.sink, {'weight': r_eq})])))

        return r_eq

    def _reduce_all_parallel(self, g: nx.Graph, debug: bool = False) -&gt; int:
        """Reduce all parallel connections in the circuit."""
        reduction_count = 0
        parallel_edges = self._find_parallel_edges(g)

        for (n1, n2), edges in parallel_edges.items():
            if len(edges) &gt; 1:
                # Calculate equivalent resistance for parallel resistors
                total_conductance = sum(1.0 / g[n1][n2]['weight'] for _ in range(len(edges)))
                r_eq = 1.0 / total_conductance

                # Replace parallel edges with a single equivalent edge
                for _ in range(len(edges) - 1):
                    g.remove_edge(n1, n2)
                g[n1][n2]['weight'] = r_eq

                if debug:
                    print(f"Parallel reduction: {len(edges)} resistors between nodes {n1}-{n2} → {r_eq:.2f}Ω")

                reduction_count += 1
                self.reduction_steps.append((f"Parallel Reduction: {n1}-{n2}", g.copy()))

        return reduction_count

    def _find_parallel_edges(self, g: nx.Graph) -&gt; Dict[Tuple[int, int], list]:
        """Find all parallel edges in the graph."""
        parallel_edges = {}

        for edge in g.edges():
            n1, n2 = min(edge), max(edge)  # Ensure consistent ordering
            key = (n1, n2)

            if key not in parallel_edges:
                parallel_edges[key] = []

            parallel_edges[key].append(edge)

        return parallel_edges

    def _reduce_all_series(self, g: nx.Graph, debug: bool = False) -&gt; int:
        """Reduce all series connections in the circuit."""
        reduction_count = 0
        series_nodes = [node for node in g.nodes() 
                      if g.degree(node) == 2 
                      and node != self.source 
                      and node != self.sink]

        for node in series_nodes:
            # Get the two neighbors of this node
            neighbors = list(g.neighbors(node))
            n1, n2 = neighbors[0], neighbors[1]

            # Get the resistances of the two edges
            r1 = g[node][n1]['weight']
            r2 = g[node][n2]['weight']

            # Calculate equivalent resistance (series: R_eq = R1 + R2)
            r_eq = r1 + r2

            # Remove the middle node and add a direct connection with equivalent resistance
            g.remove_node(node)
            g.add_edge(n1, n2, weight=r_eq)

            if debug:
                print(f"Series reduction: Node {node} between {n1}-{n2} → {r_eq:.2f}Ω")

            reduction_count += 1
            self.reduction_steps.append((f"Series Reduction: Node {node}", g.copy()))

        return reduction_count

    def _apply_y_delta_transformations(self, g: nx.Graph, debug: bool = False) -&gt; int:
        """Apply Y-Delta and Delta-Y transformations to reduce the circuit."""
        transformation_count = 0

        # Try to find Y configurations (star patterns)
        for node in list(g.nodes()):
            if node == self.source or node == self.sink:
                continue

            if g.degree(node) == 3:
                # This node could be the center of a Y configuration
                neighbors = list(g.neighbors(node))
                if len(neighbors) == 3:
                    # Apply Y to Delta transformation
                    r_a = g[node][neighbors[0]]['weight']
                    r_b = g[node][neighbors[1]]['weight']
                    r_c = g[node][neighbors[2]]['weight']

                    r_ab = (r_a * r_b + r_b * r_c + r_c * r_a) / r_c
                    r_bc = (r_a * r_b + r_b * r_c + r_c * r_a) / r_a
                    r_ca = (r_a * r_b + r_b * r_c + r_c * r_a) / r_b

                    # Remove the center node
                    g.remove_node(node)

                    # Add edges between the neighbors in a triangle (delta configuration)
                    g.add_edge(neighbors[0], neighbors[1], weight=r_ab)
                    g.add_edge(neighbors[1], neighbors[2], weight=r_bc)
                    g.add_edge(neighbors[2], neighbors[0], weight=r_ca)

                    if debug:
                        print(f"Y-Delta transformation: Center node {node} → Delta between {neighbors}")

                    transformation_count += 1
                    self.reduction_steps.append((f"Y-Delta Transformation: Node {node}", g.copy()))
                    break

        # If no Y configurations were found, try Delta configurations
        if transformation_count == 0:
            # Find triangles (cycles of length 3)
            triangles = []
            for node1 in g.nodes():
                for node2 in g.neighbors(node1):
                    for node3 in g.neighbors(node2):
                        if node3 in g.neighbors(node1) and node1 &lt; node2 &lt; node3:
                            triangles.append((node1, node2, node3))

            for triangle in triangles:
                # Apply Delta to Y transformation
                r_ab = g[triangle[0]][triangle[1]]['weight'] 
                r_bc = g[triangle[1]][triangle[2]]['weight']
                r_ca = g[triangle[2]][triangle[0]]['weight']

                denominator = r_ab + r_bc + r_ca
                r_a = (r_ab * r_ca) / denominator
                r_b = (r_ab * r_bc) / denominator
                r_c = (r_bc * r_ca) / denominator

                # Add a new center node
                new_node = max(g.nodes()) + 1
                g.add_node(new_node)

                # Remove the triangle edges
                g.remove_edge(triangle[0], triangle[1])
                g.remove_edge(triangle[1], triangle[2])
                g.remove_edge(triangle[2], triangle[0])

                # Add edges from center to corners
                g.add_edge(new_node, triangle[0], weight=r_a)
                g.add_edge(new_node, triangle[1], weight=r_b)
                g.add_edge(new_node, triangle[2], weight=r_c)

                if debug:
                    print(f"Delta-Y transformation: Triangle {triangle} → Star with center {new_node}")

                transformation_count += 1
                self.reduction_steps.append((f"Delta-Y Transformation: Triangle {triangle}", g.copy()))
                break

        return transformation_count

    def _node_elimination_method(self, g: nx.Graph, debug: bool = False) -&gt; float:
        """Calculate equivalent resistance using the node elimination method."""
        # Create a list of nodes excluding the source (ground node)
        nodes = list(g.nodes())
        nodes.remove(self.source)  # Use source as reference ground

        # If sink is not in the remaining nodes (disconnected), return infinity
        if self.sink not in nodes:
            return float('inf')

        # Create the conductance matrix
        n = len(nodes)
        G_matrix = np.zeros((n, n))

        # Node index mapping for matrix positions
        node_indices = {node: i for i, node in enumerate(nodes)}

        # Fill the conductance matrix
        for i, node_i in enumerate(nodes):
            for j, node_j in enumerate(nodes):
                if i == j:
                    # Diagonal elements: sum of conductances connected to this node
                    for neighbor in g.neighbors(node_i):
                        G_matrix[i, i] += 1.0 / g[node_i][neighbor]['weight']
                elif g.has_edge(node_i, node_j):
                    # Off-diagonal elements: negative conductance between nodes
                    G_matrix[i, j] = -1.0 / g[node_i][node_j]['weight']

        # For equivalent resistance between source and sink
        sink_index = node_indices[self.sink]

        try:
            # Calculate resistance by matrix operations
            if G_matrix.size &gt; 0:
                # If we have a non-empty matrix
                G_inv = np.linalg.inv(G_matrix)
                r_eq = 1.0 / G_matrix[node_indices[self.sink], node_indices[self.sink]]
            else:
                # Direct connection case
                r_eq = g[self.source][self.sink]['weight'] if g.has_edge(self.source, self.sink) else float('inf')
        except np.linalg.LinAlgError:
            # Fallback to direct edge if matrix is singular
            r_eq = g[self.source][self.sink]['weight'] if g.has_edge(self.source, self.sink) else float('inf')

        if debug:
            print(f"Node elimination method result: {r_eq:.4f}Ω")

        return r_eq

    def draw_circuit(self, title="Circuit"):
        """Draw the circuit with resistance values on edges."""
        g = self.original_graph.copy()
        plt.figure(figsize=(8, 6))

        # Use spring layout
        pos = nx.spring_layout(g, seed=42)

        # Draw nodes
        nx.draw_networkx_nodes(g, pos, node_size=500, node_color='lightblue')

        # Highlight source and sink nodes
        nx.draw_networkx_nodes(g, pos, nodelist=[self.source, self.sink], 
                              node_color='red', node_size=700)

        # Draw edges with resistance values as labels
        nx.draw_networkx_edges(g, pos, width=1.5)
        edge_labels = {(u, v): f"{d['weight']}Ω" for u, v, d in g.edges(data=True)}
        nx.draw_networkx_edge_labels(g, pos, edge_labels=edge_labels)

        # Draw node labels
        nx.draw_networkx_labels(g, pos)

        plt.title(title)
        plt.axis('off')
        plt.tight_layout()
        plt.show()

    def visualize_reduction_steps(self):
        """Visualize the circuit reduction process step by step."""
        steps = self.reduction_steps
        n_steps = len(steps)

        # Calculate grid dimensions
        cols = min(3, n_steps)
        rows = (n_steps + cols - 1) // cols

        plt.figure(figsize=(6 * cols, 4 * rows))

        for i, (title, g) in enumerate(steps):
            plt.subplot(rows, cols, i + 1)

            # Use spring layout
            pos = nx.spring_layout(g, seed=42)

            # Draw nodes
            nx.draw_networkx_nodes(g, pos, node_size=400, node_color='lightblue')

            # Highlight source and sink
            if self.source in g.nodes() and self.sink in g.nodes():
                nx.draw_networkx_nodes(g, pos, nodelist=[self.source, self.sink], 
                                      node_color='red', node_size=600)

            # Draw edges with resistance values as labels
            nx.draw_networkx_edges(g, pos, width=1.5)
            edge_labels = {(u, v): f"{d['weight']}Ω" for u, v, d in g.edges(data=True)}
            nx.draw_networkx_edge_labels(g, pos, edge_labels=edge_labels, font_size=8)

            # Draw node labels
            nx.draw_networkx_labels(g, pos)

            plt.title(f"Step {i+1}: {title}")
            plt.axis('off')

        plt.tight_layout()
        plt.show()
</code></pre>
<h2 id="4-example-circuits-and-visual-representations">4. Example Circuits and Visual Representations</h2>
<h3 id="41-example-1-simple-series-parallel-circuit">4.1 Example 1: Simple Series-Parallel Circuit</h3>
<pre><code>    A---[10Ω]---B---[20Ω]---C
    |                       |
   [30Ω]                   [40Ω]
    |                       |
    D-------------------E
</code></pre>
<p>ASCII representation:</p>
<pre><code>A---10Ω---B---20Ω---C
|                   |
30Ω                40Ω
|                   |
D---------E---------+
</code></pre>
<p>This circuit combines series and parallel elements:
- Path A-B-C: <span class="arithmatex">\(10Ω + 20Ω = 30Ω\)</span> (series)
- Path A-D-E-C: <span class="arithmatex">\(30Ω + 40Ω = 70Ω\)</span> (series)
- Paths are in parallel: <span class="arithmatex">\(\frac{1}{R_{eq}} = \frac{1}{30} + \frac{1}{70} = \frac{7}{210}\)</span>
- <span class="arithmatex">\(R_{eq} = \frac{210}{7} = 30Ω\)</span></p>
<h3 id="42-example-2-wheatstone-bridge-circuit">4.2 Example 2: Wheatstone Bridge Circuit</h3>
<pre><code>    A---[10Ω]---B
    |           |
   [20Ω]       [30Ω]
    |     [50Ω]  |
    C---[40Ω]---D
</code></pre>
<p>ASCII representation:</p>
<pre><code>    A---10Ω---B
    |         |
   20Ω       30Ω
    |    50Ω  |
    C----     |
    |    \    |
    |     \   |
   40Ω      \ |
    |        \|
    D---------+
</code></pre>
<p>This circuit has a bridge element (50Ω between B and C), which cannot be reduced using only series and parallel rules. We need Y-Δ transformation:</p>
<ol>
<li>Apply Y-Δ transformation to convert the bridge into a reducible form</li>
<li>Then apply series-parallel reductions</li>
<li>If needed, use node elimination method</li>
</ol>
<h3 id="43-example-3-complex-mesh-circuit">4.3 Example 3: Complex Mesh Circuit</h3>
<pre><code>    A---[2Ω]---B---[5Ω]---C
    |         |           |
   [4Ω]      [7Ω]        [3Ω]
    |         |           |
    D---[8Ω]--E---[6Ω]---F
</code></pre>
<p>ASCII representation:</p>
<pre><code>A---2Ω---B---5Ω---C
|        |        |
4Ω      7Ω       3Ω
|        |        |
D---8Ω---E---6Ω---F
</code></pre>
<p>This complex mesh circuit requires multiple reduction steps:
1. Cannot be directly reduced with series-parallel only
2. Need Y-Δ transformations for certain configurations
3. Final solution may require node elimination method</p>
<h2 id="5-algorithm-analysis">5. Algorithm Analysis</h2>
<h3 id="51-time-complexity">5.1 Time Complexity</h3>
<ul>
<li><strong>Series and Parallel Reductions</strong>: <span class="arithmatex">\(O(|V| + |E|)\)</span> per iteration</li>
<li><strong>Y-Δ Transformations</strong>: <span class="arithmatex">\(O(|V|^3)\)</span> in worst case</li>
<li><strong>Node Elimination Method</strong>: <span class="arithmatex">\(O(|V|^3)\)</span> for matrix operations</li>
<li><strong>Overall</strong>: <span class="arithmatex">\(O(|V|^3)\)</span> dominated by the more complex operations</li>
</ul>
<h3 id="52-space-complexity">5.2 Space Complexity</h3>
<ul>
<li><span class="arithmatex">\(O(|V|^2 + |E|)\)</span> for graph representation and matrices</li>
</ul>
<h3 id="53-strengths">5.3 Strengths</h3>
<ol>
<li><strong>Handles Any Circuit Topology</strong>: Works with any valid resistor configuration</li>
<li><strong>Automated Analysis</strong>: Systematically reduces complex circuits</li>
<li><strong>Visual Insights</strong>: Provides step-by-step visualization of circuit reduction</li>
<li><strong>Multiple Methods</strong>: Combines different techniques for comprehensive analysis</li>
</ol>
<h3 id="54-potential-improvements">5.4 Potential Improvements</h3>
<ol>
<li><strong>Optimization for Sparse Circuits</strong>: Use sparse matrix techniques for large circuits</li>
<li><strong>Heuristic Selection</strong>: Develop heuristics to choose optimal reduction sequences</li>
<li><strong>Parallel Processing</strong>: Identify independent subcircuits for parallel calculation</li>
<li><strong>Extension to AC Circuits</strong>: Add support for complex impedances in AC circuit analysis</li>
</ol>
<h2 id="6-conclusion">6. Conclusion</h2>
<p>Graph theory provides a powerful framework for calculating equivalent resistance in electrical circuits. By representing circuits as graphs and applying systematic reduction techniques, we can handle circuits of arbitrary complexity. The combination of series-parallel reductions, Y-Δ transformations, and node elimination methods ensures that we can solve any valid resistor network.</p>
<p>This approach not only automates circuit analysis but also provides insights into the mathematical structure of electrical networks, demonstrating the elegant intersection of graph theory and electrical engineering principles.</p>
<h2 id="7-example-python-usage">7. Example Python Usage</h2>
<pre><code class="language-python">import networkx as nx

# Create a circuit graph
g = nx.Graph()

# Example: Create a bridge circuit (Wheatstone bridge)
g.add_edge('A', 'B', weight=10)  # 10Ω
g.add_edge('A', 'C', weight=20)  # 20Ω
g.add_edge('B', 'D', weight=30)  # 30Ω
g.add_edge('C', 'D', weight=40)  # 40Ω
g.add_edge('B', 'C', weight=50)  # 50Ω (bridge element)

# Create analyzer and calculate equivalent resistance
analyzer = CircuitAnalyzer(g, 'A', 'D')
r_eq = analyzer.calculate_equivalent_resistance(debug=True)

print(f"Equivalent resistance: {r_eq} Ω")

# Draw original circuit and visualization of reduction steps
analyzer.draw_circuit("Wheatstone Bridge Circuit")
analyzer.visualize_reduction_steps()
</code></pre>
</div>
</div><footer>
<div aria-label="Footer Navigation" class="rst-footer-buttons" role="navigation">
<a class="btn btn-neutral float-left" href="../../4%20Electromagnetism/Problem_1/" title="Lorentz Force Simulation"><span class="icon icon-circle-arrow-left"></span> Previous</a>
<a class="btn btn-neutral float-right" href="../../6%20Statistics/Problem_1/" title="Problem 1">Next <span class="icon icon-circle-arrow-right"></span></a>
</div>
<hr/>
<div role="contentinfo">
<!-- Copyright etc -->
</div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
</div>
</div>
</section>
</div>
<div aria-label="Versions" class="rst-versions" role="note">
<span class="rst-current-version" data-toggle="rst-current-version">
<span><a href="../../4%20Electromagnetism/Problem_1/" style="color: #fcfcfc">« Previous</a></span>
<span><a href="../../6%20Statistics/Problem_1/" style="color: #fcfcfc">Next »</a></span>
</span>
</div>
<script src="../../../js/jquery-3.6.0.min.js"></script>
<script>var base_url = "../../..";</script>
<script src="../../../js/theme_extra.js"></script>
<script src="../../../js/theme.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script src="../../../search/main.js"></script>
<script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>
</body>
</html>
